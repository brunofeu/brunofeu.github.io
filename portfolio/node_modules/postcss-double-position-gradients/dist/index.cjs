"use strict";const e=require("postcss-value-parser"),t=/(repeating-)?(conic|linear|radial)-gradient\([\W\w]*\)/i,r=/^(repeating-)?(conic|linear|radial)-gradient$/i,a=e=>"div"===e.type&&","===e.value;function n(t){let r=!1;try{r=!1!==e.unit(null==t?void 0:t.value)}catch(e){}return r}module.exports=function(i){const o=!("preserve"in Object(i))||Boolean(i.preserve);return{postcssPlugin:"postcss-double-position-gradients",Declaration(i,{result:l}){if(!t.test(i.value))return;let c;try{c=e(i.value)}catch(e){i.warn(l,`Failed to parse value '${i.value}' as a CSS gradient. Leaving the original value intact.`)}if(void 0===c)return;c.walk((e=>{if("function"!==e.type||!r.test(e.value))return;return e.nodes.filter((e=>"word"===e.type)).forEach(((t,r,i)=>{const o=Object(i[r-1]),l=Object(i[r-2]),c=Object(i[r+1]);if(l.type&&n(o)&&n(t)){const r={type:l.type,value:l.value},n={type:"div",value:",",before:a(c)?c.before:"",after:a(c)?"":" "};!function(e,t,...r){const a=e.findIndex((e=>e===t));e.splice.apply(e,[a-1,0].concat(Array.prototype.slice.call(...r,0)))}(e.nodes,t,[n,r])}})),!1}));const s=c.toString();s!==i.value&&(o?i.cloneBefore({value:s}):i.value=s)}}},module.exports.postcss=!0;
//# sourceMappingURL=index.cjs.map
